# 花指令

是用来抵御静态分析的一种手段，其原理是在指令流中插入很多“数据垃圾”，干扰反汇编软件的判断，使之错误地确定指令起始位置。（具体可参考[《加密与解密（第4版）》](https://book.douban.com/subject/30288807/)17章的17.2.1）



## 0x00 花指令处理前

用了花指令的程序，IDA打开的时候可能长这样

![1569924823666.png](https://i.loli.net/2019/10/01/zSdK2y6VhMIP3OW.png)

其中会有莫名奇妙的跳转和看起来诡异的跳转地址，跳转地址附近的汇编指令也奇奇怪怪，<kbd>F5</kbd>无法得到反汇编代码

![1569924905734.png](https://i.loli.net/2019/10/01/WtHdUbYxg8E2RD6.png)

这个 `jb  short near ptr loc_8048775+1` & `jnb  short near ptr loc_8048775+1`就是花指令的一种。（留意一下这个+1，正常跳转指令不长这样的）

## 0x01 去除花指令

对这个花指令后面的部分选中后<kbd>U</kbd>还原成16进制代码，可以看到

![1569925298096.png](https://i.loli.net/2019/10/01/kBjEQewDZa2Fd4U.png)

挨着花指令的`.text:08048775     db 0E1h`是个垃圾数据，选中`0x8048776` 到`0x804877D`部分<kbd>C</kbd>对该部分16进制码进行重新分析

![1569925586687.png](https://i.loli.net/2019/10/01/sWYbhrk679xgjZI.png)

可见，这个花指令的原理是跳转到`0x8048776`，并且在跳转指令和目标地址中间插入了一个数据垃圾`db 0E1h`。其实无论这个垃圾数据是什么，都不会被执行，也就不影响程序正常工作。

## 0x02 最后一步

去除花指令后，选中被混淆的汇编码，按<kbd>P</kbd>创建函数，即可按<kbd>F5</kbd>对汇编代码反汇编了。